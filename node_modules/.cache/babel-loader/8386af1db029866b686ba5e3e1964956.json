{"ast":null,"code":"import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { getWillChangeName } from '../../value/use-will-change/get-will-change-name.mjs';\nimport { addUniqueItem } from '../../utils/array.mjs';\n\nfunction makeState(_ref, props, context, presenceContext, isStatic) {\n  let {\n    applyWillChange = false,\n    scrapeMotionValuesFromProps,\n    createRenderState,\n    onMount\n  } = _ref;\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n\n  if (onMount) {\n    state.mount = instance => onMount(props, instance, state);\n  }\n\n  return state;\n}\n\nconst makeUseVisualState = config => (props, isStatic) => {\n  const context = useContext(MotionContext);\n  const presenceContext = useContext(PresenceContext);\n\n  const make = () => makeState(config, props, context, presenceContext, isStatic);\n\n  return isStatic ? make() : useConstant(make);\n};\n\nfunction addWillChange(willChange, name) {\n  const memberName = getWillChangeName(name);\n\n  if (memberName) {\n    addUniqueItem(willChange, memberName);\n  }\n}\n\nfunction forEachDefinition(props, definition, callback) {\n  const list = Array.isArray(definition) ? definition : [definition];\n\n  for (let i = 0; i < list.length; i++) {\n    const resolved = resolveVariantFromProps(props, list[i]);\n\n    if (resolved) {\n      const {\n        transitionEnd,\n        transition,\n        ...target\n      } = resolved;\n      callback(target, transitionEnd);\n    }\n  }\n}\n\nfunction makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {\n  var _a;\n\n  const values = {};\n  const willChange = [];\n  const applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;\n  const motionValues = scrapeMotionValues(props, {});\n\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n\n  let {\n    initial,\n    animate\n  } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === undefined) initial = context.initial;\n    if (animate === undefined) animate = context.animate;\n  }\n\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate : initial;\n\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    forEachDefinition(props, variantToSet, (target, transitionEnd) => {\n      for (const key in target) {\n        let valueTarget = target[key];\n\n        if (Array.isArray(valueTarget)) {\n          /**\n           * Take final keyframe if the initial animation is blocked because\n           * we want to initialise at the end of that blocked animation.\n           */\n          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index];\n        }\n\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n\n      for (const key in transitionEnd) {\n        values[key] = transitionEnd[key];\n      }\n    });\n  } // Add animating values to will-change\n\n\n  if (applyWillChange) {\n    if (animate && initial !== false && !isAnimationControls(animate)) {\n      forEachDefinition(props, animate, target => {\n        for (const key in target) {\n          addWillChange(willChange, key);\n        }\n      });\n    }\n\n    if (willChange.length) {\n      values.willChange = willChange.join(\",\");\n    }\n  }\n\n  return values;\n}\n\nexport { makeUseVisualState };","map":{"version":3,"sources":["C:/Users/74760/Desktop/VScode/React/Portfolio/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs"],"names":["useContext","isAnimationControls","PresenceContext","resolveVariantFromProps","useConstant","resolveMotionValue","MotionContext","isControllingVariants","isVariantNode","getWillChangeName","addUniqueItem","makeState","props","context","presenceContext","isStatic","applyWillChange","scrapeMotionValuesFromProps","createRenderState","onMount","state","latestValues","makeLatestValues","renderState","mount","instance","makeUseVisualState","config","make","addWillChange","willChange","name","memberName","forEachDefinition","definition","callback","list","Array","isArray","i","length","resolved","transitionEnd","transition","target","shouldApplyWillChange","scrapeMotionValues","_a","values","style","undefined","motionValues","key","initial","animate","isControllingVariants$1","isVariantNode$1","inherit","isInitialAnimationBlocked","variantToSet","valueTarget","index","join"],"mappings":"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","sourcesContent":["import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { getWillChangeName } from '../../value/use-will-change/get-will-change-name.mjs';\nimport { addUniqueItem } from '../../utils/array.mjs';\n\nfunction makeState({ applyWillChange = false, scrapeMotionValuesFromProps, createRenderState, onMount, }, props, context, presenceContext, isStatic) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = (instance) => onMount(props, instance, state);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext, isStatic);\n    return isStatic ? make() : useConstant(make);\n};\nfunction addWillChange(willChange, name) {\n    const memberName = getWillChangeName(name);\n    if (memberName) {\n        addUniqueItem(willChange, memberName);\n    }\n}\nfunction forEachDefinition(props, definition, callback) {\n    const list = Array.isArray(definition) ? definition : [definition];\n    for (let i = 0; i < list.length; i++) {\n        const resolved = resolveVariantFromProps(props, list[i]);\n        if (resolved) {\n            const { transitionEnd, transition, ...target } = resolved;\n            callback(target, transitionEnd);\n        }\n    }\n}\nfunction makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {\n    var _a;\n    const values = {};\n    const willChange = [];\n    const applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        forEachDefinition(props, variantToSet, (target, transitionEnd) => {\n            for (const key in target) {\n                let valueTarget = target[key];\n                if (Array.isArray(valueTarget)) {\n                    /**\n                     * Take final keyframe if the initial animation is blocked because\n                     * we want to initialise at the end of that blocked animation.\n                     */\n                    const index = isInitialAnimationBlocked\n                        ? valueTarget.length - 1\n                        : 0;\n                    valueTarget = valueTarget[index];\n                }\n                if (valueTarget !== null) {\n                    values[key] = valueTarget;\n                }\n            }\n            for (const key in transitionEnd) {\n                values[key] = transitionEnd[key];\n            }\n        });\n    }\n    // Add animating values to will-change\n    if (applyWillChange) {\n        if (animate && initial !== false && !isAnimationControls(animate)) {\n            forEachDefinition(props, animate, (target) => {\n                for (const key in target) {\n                    addWillChange(willChange, key);\n                }\n            });\n        }\n        if (willChange.length) {\n            values.willChange = willChange.join(\",\");\n        }\n    }\n    return values;\n}\n\nexport { makeUseVisualState };\n"]},"metadata":{},"sourceType":"module"}